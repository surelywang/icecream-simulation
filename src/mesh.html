<html lang="en">

<head>
	<title>Ice Cream Simulation</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			margin: 0px;
			overflow: hidden;
		}
		#info {
			color: #fff;
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			z-index: 100;
			display:block;
		}
		#info a {
			color: #ff0080;
			font-weight: bold;
		}
	</style>
</head>

<body>

<div id="info">Ice Cream Simulation | Natalie Khamphanh, Lauren Martini, and Shirley Wang</div>

<script src="../build/three.js"></script>
<script src="js/WebGL.js"></script>

<script src="js/perlin.js"></script>



<script type="text/javascript" id="mainCode">

// Base code = https://codepen.io/kaigth/
// Reference 2 = https://codepen.io/kekkorider/pen/BRrgbY/

// Scene setups
var SW = window.innerWidth, SH = window.innerHeight;
var scene = new THREE.Scene();	// scene
var camera, renderer;			// camera, render

 var loader = new THREE.TextureLoader();
    loader.crossOrigin = "";
    // var texture1 = loader.load('https://dairystore.unl.edu/images/IceCreamswatch/120508_Strawberry_Cheesecake_007.jpg');

    var texture1 = loader.load('https://1.bp.blogspot.com/-wDFbkfBw0A4/U1MtNZRxNCI/AAAAAAAAcYI/0Psjl14hlVU/s1600/haagen-daz-green-tea-ice-cream-03.JPG');
    var texture2 = loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR25NP9-fIGRiZQlVpOasRPML3wOTtB6Rm0hTelEHr9EtyaOGSNHQ');
    var texture3 = loader.load("https://st.depositphotos.com/1003495/1932/i/950/depositphotos_19328199-stock-photo-wafer-texture.jpg");
      texture3.wrapS = THREE.RepeatWrapping;
      texture3.wrapT = THREE.RepeatWrapping;
    var texture4 = loader.load('https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRGVtyLH5YjAK0MDfe-esJbRY0Rev2Oe6aOGSo7XPhcZaOiyRVbIQ');

var icemat = new THREE.MeshPhongMaterial({
      map: texture1,
      color: 0xe8e4c9,
      transparent: false,
      bumpMap: texture1,
      bumpScale: 0.15,
      displacementMap: texture2,
      displacementScale: 0.01
    });

var cone_mat = new THREE.MeshPhongMaterial({
      map: texture3,
      color: 0xe1c699,
      transparent: false,
      bumpMap: texture3,
      bumpScale: 0.5
    });


var sphere_geometry = new THREE.SphereGeometry(0.1, 128, 128);
var material = new THREE.MeshNormalMaterial();
var sphere = new THREE.Mesh(sphere_geometry, icemat);
sphere.position.y = 1;
sphere.castShadow = true;


// Call initializer and then render scene
init();
render();


// Intiialize scene
function init() {

	// Set camera
	camera = new THREE.PerspectiveCamera(60, SW / SH, 0.1, 1000);
  camera.position.z = 5;

    // Set renderer
	renderer = new THREE.WebGLRenderer();
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.setSize(SW, SH);
	document.body.appendChild(renderer.domElement);

	// Add lights to scene
	var ambient = new THREE.AmbientLight(0xffffff);
	var spot = new THREE.SpotLight( 0xffffff, 1);
	var point = new THREE.DirectionalLight( 0xD3D3D3 );
	//spot.position.set( 0, 0, 0 );
	//scene.add( spot );
	scene.add( ambient );
	scene.add( point );

  var cone_geo = new THREE.ConeGeometry(0.7, 2.5, 10);
  var cone = new THREE.Mesh(cone_geo, cone_mat);
  cone.scale.y = -1;
  cone.position.y = -.75;
  cone.geometry.computeVertexNormals(true);
  cone.castShadow = true;


  scene.add(cone);

  scene.add(sphere);

}

// Note: call this before animate
function update() {
  // go through vertices here and reposition them

  var time = performance.now() * 0.0009;
  var k = 2;

  for (var i = 0; i < sphere.geometry.vertices.length; i++) {
    var p = sphere.geometry.vertices[i];
    p.normalize();
    p.multiplyScalar(0.95 + 0.01 * noise.perlin3(k*p.x, k*p.y + time, k*p.z));
    
    // Apply deform sphere by "melting" sphere from top-down
    if (p.y > -0.6) {
      p.y -= 2 * 1/i;
    }
    // if (i <= sphere.geometry.vertices.length/2) {
    //   p.x -= 0.000000001 * i;
    // } else {
    //   p.x += 0.000000001 * i;
    // }
  }

  sphere.geometry.verticesNeedUpdate = true;
  sphere.geometry.computeVertexNormals();
  sphere.geometry.normalsNeedUpdate = true;

}


// Looping and Rendering
function render() {


  update();
  renderer.render(scene, camera);
  requestAnimationFrame(render);
  
}

</script>
</body>
</html>


